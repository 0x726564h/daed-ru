scalar Duration
scalar Time

schema {
  query: Query
  mutation: Mutation
}
type Query {
  configs(id: ID, selected: Boolean): [Config!]!
  subscriptions(id: ID): [Subscription!]!
  groups(id: ID): [Group!]!
  group(name: String!): Group!
  nodes(id: ID, subscriptionId: ID, first: Int, after: ID): NodesConnection!
}
type Mutation {
  createConfig(global: String!, dns: String!, routing: String!): Config!
  updateConfig(id: ID!, global: String, dns: String, routing: String): Config!
  removeConfig(id: ID!): Int!
  selectConfig(id: ID!): Int!
  run(dry: Boolean!): Int!

  importNodes(rollbackError: Boolean!, args: [ImportArgument!]!): [NodeImportResult!]!
  removeNodes(ids: [ID!]!): Int!
  tagNode(id: ID!, tag: String!): Int!

  importSubscription(rollbackError: Boolean!, arg: ImportArgument!): SubscriptionImportResult!
  removeSubscriptions(ids: [ID!]!): Int!
  tagSubscription(id: ID!, tag: String!): Int!
  updateSubscription(id: ID!): Subscription!

  createGroup(name: String!, policy: Policy!, policyParams: [PolicyParam!]): Group!
  groupAddSubscriptions(id: ID!, subscriptionIDs: [ID!]!): Int!
  groupDelSubscriptions(id: ID!, subscriptionIDs: [ID!]!): Int!
  groupAddNodes(id: ID!, nodeIDs: [ID!]!): Int!
  groupDelNodes(id: ID!, nodeIDs: [ID!]!): Int!
  renameGroup(id: ID!, name: String!): Int!
  removeGroup(id: ID!): Int!
}
input ImportArgument {
  link: String!
  tag: String
}
type NodeImportResult {
  link: String!
  error: String
  node: Node
}
type SubscriptionImportResult {
  link: String!
  nodeImportResult: [NodeImportResult!]!
  sub: Subscription!
}
input PolicyParam {
  key: String!
  val: String!
}

type Config {
  global: Global!
  routing: Routing!
  dns: Dns!
  selected: Boolean!
}

type Function {
  name: String!
  not: Boolean!
  params: [Param!]!
}
type Param {
  key: String!
  val: String!
}

type AndFunctions {
  and: [Function!]!
}

type Plaintext {
  val: String!
}

union AndFunctionsOrPlaintext = AndFunctions | Plaintext
union FunctionOrPlaintext = Function | Plaintext

type Global {
  tproxyPort: Int!
  logLevel: String!
  tcpCheckUrl: String!
  udpCheckDns: String!
  checkInterval: Duration!
  checkTolerance: Duration!
  dnsUpstream: String!
  lanInterface: [String!]!
  lanNatDirect: Boolean!
  wanInterface: [String!]!
  allowInsecure: Boolean!
  dialMode: String!
}

type Group {
  id: ID!
  name: String!
  nodes: [Node!]!
  subscriptions: [Subscription!]!
  policy: Policy!
  policyParams: [Param!]!
}
enum Policy {
  random
  fixed
  min_avg10
  min_moving_avg
  min
}

type Routing {
  rules: [RoutingRule!]!
  fallback: FunctionOrPlaintext!
}
type RoutingRule {
  conditions: AndFunctions!
  outbound: Function!
}

type Dns {
  upstream: [Param!]!
  routing: DnsRouting!
}
type DnsRouting {
  request: Routing!
  response: Routing!
}

type PageInfo {
  startCursor: ID
  endCursor: ID
  hasNextPage: Boolean!
}

type Node {
  id: ID!
  link: String!
  name: String!
  address: String!
  protocol: String!
  tag: String
  subscriptionID: ID
}
type NodesConnection {
  totalCount: Int!
  edges: [Node!]!
  pageInfo: PageInfo!
}

type Subscription {
  id: ID!
  updatedAt: Time!
  tag: String
  link: String!
  status: String!
  info: String!
  nodes(first: Int, after: ID): NodesConnection!
}
